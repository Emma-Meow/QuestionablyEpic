//prettier-ignore
import { addMissingTimestamps, getUniqueObjectsFromArray, reduceTimestamps, fightDuration, importHealerLogData, importDamageLogData, importCastsLogData,
  durationmaker, sumDamage, importSummaryData, importExternalCastsLogData, importCharacterIds, importEnemyCasts, importEnemyIds, importRaidHealth, importDefensiveLogData } from "../../CooldownPlanner/Functions/Functions";
import moment from "moment";
import { cooldownDB } from "../../CooldownPlanner/Data/CooldownDB";

/* =============================================
   This Function Imports all the Data for the Chart/Log Details
   component. This Function should be bound to the Component that is imported into, so all data
   retreived by it is returned/setting the state in that component. This is
   sent down through the Fight Selector Button Component, down to the Log
   Import Component. When a menu item generated by the Logimport function
   is clicked, It will call this function (as well as a few others, i.e
   setting the current report id etc), The start time and end time are
   passed through to this function.
  =============================================*/

/* - PLease Note that all the 'this.' statements in this file do not actually affect this file. - */
/* -------------- They are refering to the component the function is imported into. ------------- */

/* ------------------------- Not used Currently : Candidate for deletion ------------------------ */
// function getUnique(arr, comp) {
//   /* ---------------------------- Store the comparison  values in array --------------------------- */
//   const unique = arr
//     .map((e) => e[comp])
//     /* --------------------------- Store the indexes of the unique objects -------------------------- */
//     .map((e, i, final) => final.indexOf(e) === i && i)
//     /* --------------------- Eliminate the false indexes & return unique objects -------------------- */
//     .filter((e) => arr[e])
//     .map((e) => arr[e]);
//   return unique;
// }

/* ---------------------------------------------------------------------------------------------- */
/*                                      Chart Update Function                                     */
/* ---------------------------------------------------------------------------------------------- */

export default async function updatechartdata(starttime, endtime, reportID, boss) {
  /* -------- Note we are using alot of imported functions Here to save bloat in the Code. -------- */

  /* -- Set the Loading State of the loading spinner so that the user knows data is being loaded. - */
  this.setState({ loadingcheck: true });

  let healerDurations = [];
  let sortedDataUnmitigatedWithCooldowns = [];
  let sortedDataMitigatedDamageWithCooldowns = [];
  let sortedDataUnmitigatedNoCooldowns = [];
  let sortedDataMitigatedDamageNoCooldowns = [];
  let damagingAbilities = [];

  /* ---- Fight Length of the selected report is calculated and coverted to seconds as a string --- */
  const fightLength = moment.duration(fightDuration(endtime, starttime)).asSeconds().toString();

  /* ----------- Import Healer Info from the Logs healing table for each healing class. ----------- */
  const healers = await importHealerLogData(starttime, endtime, this.state.reportid);

  /* ------------------------------ Import Character IDS from the log ----------------------------- */
  const playerIDs = await importCharacterIds(starttime, endtime, this.state.reportid);

  /* -------------------------------- Import Enemy IDS from the log ------------------------------- */
  const enemyIDs = await importEnemyIds(starttime, endtime, this.state.reportid);
  /* ---------------------- Import summary Info from the Logs Summary table. ---------------------- */
  /* ------------ This contains our data for Gear, Stats, Conduits, Soulbinds etc etc. ------------ */
  const summary = await importSummaryData(starttime, endtime, this.state.reportid);

  /* --------------- Import all the damage-taken from the log for friendly targets. --------------- */
  const damage = await importDamageLogData(starttime, endtime, this.state.reportid, boss);

  const health = await importRaidHealth(starttime, endtime, this.state.reportid);

  /* --------------------------- Map Healer Data for ID, Name and Class. -------------------------- */
  const healerIDName = healers.map((key) => ({
    id: key.id,
    name: key.name,
    class: key.type,
  }));

  /* ------------------ Import the log data for Casts for each healer in the log. ----------------- */
  const cooldowns = await importCastsLogData(
    starttime,
    endtime,
    this.state.reportid,
    healers.map((key) => key.id),
  );

  const defensives = await importDefensiveLogData(starttime, endtime, this.state.reportid);

  /* ------------------------- Import Log data for external cooldown casts ------------------------ */
  const externals = await importExternalCastsLogData(
    starttime,
    endtime,
    this.state.reportid,
    healers.map((key) => key.id),
  );

  /* ------------------------------- Import Log data for enemy casts ------------------------------ */
  const enemyCasts = await importEnemyCasts(starttime, endtime, this.state.reportid);

  /* ---------------- Map the damaging abilities and guids to an array of objects. ---------------- */
  damage.map((key) =>
    damagingAbilities.push({
      ability: key.ability.name,
      guid: key.ability.guid,
    }),
  );

  /* ---------------- Filter the array to unique entries for Ability name and Guid. --------------- */
  const uniqueArray = damagingAbilities.filter((ele, ind) => ind === damagingAbilities.findIndex((elem) => elem.ability === ele.ability && elem.guid === ele.guid));
  const uniqueAbilityNames = Array.from(new Set(damage.map((key) => key.ability.name)));
  /* -- Map the cd data imported into an array of cds in this format (HealerName - CooldownName) -- */
  /* ------ Unique list of Cds from the previously mapped array is made, then create an array ----- */
  /* -------- We do this for the chart data as these are needed for dataKeys for the chart. ------- */
  const uniqueArrayCD = Array.from(
    new Set(
      cooldowns.map(
        (key) =>
          healerIDName
            .filter((obj) => {
              return obj.id === key.sourceID;
            })
            .map((obj) => obj.name) +
          " - " +
          key.ability.name,
      ),
    ),
  );

  /* --------------------- Map the cooldown casts into objects for the chart. --------------------- */
  /* ---- Map CD Casts with duration function to add extra data for the times the CD is active ---- */
  /* ------------- These are pushed into the new array healerDurations during the map ------------- */
  cooldowns
    .filter((key) =>
      cooldownDB
        .filter((filter) => filter.cdPlannerImport === true)
        .map((obj) => obj.guid)
        .includes(key.ability.guid),
    )
    .map((key) => ({
      ability: key.ability.name,
      guid: key.ability.guid,
      timestamp: moment.utc(fightDuration(key.timestamp, starttime)).startOf("second").valueOf(),
      [healerIDName
        .filter((obj) => {
          return obj.id === key.sourceID;
        })
        .map((obj) => obj.name) +
      " - " +
      key.ability.name]: 1,
    }))
    .map((key) => healerDurations.push(durationmaker(key.guid, key.timestamp, Object.getOwnPropertyNames(key).slice(3), moment.utc(fightDuration(endtime, starttime)).startOf("second").valueOf())));

  /* -------------------------- Create Ability List With Guids for legend ------------------------- */
  /* ----------------- Get Unique Objects from Ability list for the custom legend ----------------- */
  /* -------------------- Concat the Unique Ability List with the Cooldown List ------------------- */
  const uniqueArrayNewForLegend = getUniqueObjectsFromArray(
    damage.map((key) => ({
      value: key.ability.name,
      id: key.ability.guid,
    })),
    "id",
  ).concat(uniqueArrayCD);

  /* ----------------------- Map the Unmitigated damage taken & timestamps. ----------------------- */
  /* ---- Timestamps are made by minusing the start of the the fight in ms from the end in ms. ---- */
  /* - Then converted to start of nearest second otherwise the chart will show each individual ms - */
  /* ------------------- We Don't need to delve that deep into MS for the chart. ------------------ */
  const unmitigatedDamageMap = damage.map((key) => ({
    timestamp: moment.utc(fightDuration(key.timestamp, starttime)).startOf("second").valueOf(),
    [key.ability.name]: key.unmitigatedAmount,
  }));

  /* ------------------------ Map the Mitigated damage taken & timestamps. ------------------------ */
  /* ---- Timestamps are made by minusing the start of the the fight in ms from the end in ms. ---- */
  /* - Then converted to start of nearest second otherwise the chart will show each individual ms - */
  /* ------------------- We Don't need to delve that deep into MS for the chart. ------------------ */
  const mitigatedDamageMap = damage.map((key) => ({
    timestamp: moment.utc(fightDuration(key.timestamp, starttime)).startOf("second").valueOf(),
    [key.ability.name]: key.amount,
  }));

  /* ------------------------- Map cooldown casts for the Timeline Table. ------------------------- */
  const updateddatacastsTimeline = cooldowns
    .filter((key) =>
      cooldownDB
        .filter((filter) => filter.cdPlannerImport === true)
        .map((obj) => obj.guid)
        .includes(key.ability.guid),
    )
    .map((key) => ({
      ability: key.ability.name,
      guid: key.ability.guid,
      timestamp: moment.utc(fightDuration(key.timestamp, starttime)).startOf("second").format("mm:ss"),
      name: healerIDName
        .filter((obj) => {
          return obj.id === key.sourceID;
        })
        .map((obj) => obj.name)
        .toString(),
      class: healerIDName
        .filter((obj) => {
          return obj.id === key.sourceID;
        })
        .map((obj) => obj.class)
        .toString(),
    }));

  /* ------------------------- Map cooldown casts for the Timeline Table. ------------------------- */
  const updateddatacastsExternalsTimeline = externals.map((key) => ({
    ability: key.ability.name,
    guid: key.ability.guid,
    timestamp: moment.utc(fightDuration(key.timestamp, starttime)).startOf("second").format("mm:ss"),
    caster: healerIDName
      .filter((obj) => {
        return obj.id === key.sourceID;
      })
      .map((obj) => obj.name)
      .toString(),
    target: playerIDs
      .filter((obj) => {
        return obj.id === key.targetID;
      })
      .map((obj) => obj.name)
      .toString(),
    casterClass: healerIDName
      .filter((obj) => {
        return obj.id === key.sourceID;
      })
      .map((obj) => obj.class)
      .toString(),
    targetClass: playerIDs
      .filter((obj) => {
        return obj.id === key.targetID;
      })
      .map((obj) => obj.class)
      .toString(),
  }));

  /* ------------------------- Map enemy casts for the Enemy Timeline Table. ------------------------- */
  const enemyCastsTimeline = enemyCasts.map((key) => ({
    ability: key.ability.name,
    guid: key.ability.guid,
    timestamp: moment.utc(fightDuration(key.timestamp, starttime)).startOf("second").format("mm:ss"),
    name: enemyIDs
      .filter((obj) => {
        return obj.id === key.sourceID;
      })
      .map((obj) => obj.name)
      .toString(),
    id: key.sourceID,
    parentId: key.sourceID,
  }));

  /* ------------------------ Map External casts for the External Timeline ------------------------ */
  const updateddatacastsExternalTimeline = cooldowns.map((key) => ({
    ability: key.ability.name,
    guid: key.ability.guid,
    timestamp: moment.utc(fightDuration(key.timestamp, starttime)).startOf("second").format("mm:ss"),
    name: healerIDName
      .filter((obj) => {
        return obj.id === key.sourceID;
      })
      .map((obj) => obj.name)
      .toString(),
    class: healerIDName
      .filter((obj) => {
        return obj.id === key.sourceID;
      })
      .map((obj) => obj.class)
      .toString(),
  }));

  /* ------------------------ Map Defensives casts for the External Timeline ------------------------ */
  const defensiveCasts = defensives.map((key) => ({
    ability: key.ability.name,
    guid: key.ability.guid,
    timestamp: moment.utc(fightDuration(key.timestamp, starttime)).startOf("second").format("mm:ss"),
    name: playerIDs
      .filter((obj) => {
        return obj.id === key.sourceID;
      })
      .map((obj) => obj.name)
      .toString(),
    class: playerIDs
      .filter((obj) => {
        return obj.id === key.sourceID;
      })
      .map((obj) => obj.class)
      .toString(),
  }));

  const healthUpdated = health;

  /* ----------------------- Flatten the map we just created into an array. ----------------------- */
  let cooldownwithdurations = healerDurations.flat();

  /* ----------------- Create any missing timestamps in the fight (i.e no damage) ----------------- */
  /* --------- These are needed so the chart doesn't stretch the areas to the next point.) -------- */
  let times = addMissingTimestamps(fightDuration(endtime, starttime), uniqueAbilityNames, uniqueArrayCD);

  /* ------- Concat the damage arrays with the cooldown durations with the missing durations ------ */
  let unmitigatedDamageFromLogWithTimesAddedAndCooldowns = unmitigatedDamageMap.concat(cooldownwithdurations, times);
  unmitigatedDamageFromLogWithTimesAddedAndCooldowns = unmitigatedDamageFromLogWithTimesAddedAndCooldowns.concat(healthUpdated);

  let mitigatedDamageFromLogWithTimesAddedAndCooldowns = mitigatedDamageMap.concat(cooldownwithdurations, times);
  mitigatedDamageFromLogWithTimesAddedAndCooldowns = mitigatedDamageFromLogWithTimesAddedAndCooldowns.concat(healthUpdated);

  let unmitigatedDamageFromLogWithTimesAddedNoCooldowns = unmitigatedDamageMap.concat(times);
  unmitigatedDamageFromLogWithTimesAddedNoCooldowns = unmitigatedDamageFromLogWithTimesAddedNoCooldowns.concat(healthUpdated);

  let mitigatedDamageFromLogWithTimesAddedNoCooldowns = mitigatedDamageMap.concat(times);
  mitigatedDamageFromLogWithTimesAddedNoCooldowns = mitigatedDamageFromLogWithTimesAddedNoCooldowns.concat(healthUpdated);

  /* -------------------------------- Sort the Arrays by Timestamp -------------------------------- */
  unmitigatedDamageFromLogWithTimesAddedAndCooldowns.sort((a, b) => (a.timestamp > b.timestamp ? 1 : -1));
  mitigatedDamageFromLogWithTimesAddedAndCooldowns.sort((a, b) => (a.timestamp > b.timestamp ? 1 : -1));
  unmitigatedDamageFromLogWithTimesAddedNoCooldowns.sort((a, b) => (a.timestamp > b.timestamp ? 1 : -1));
  mitigatedDamageFromLogWithTimesAddedNoCooldowns.sort((a, b) => (a.timestamp > b.timestamp ? 1 : -1));

  /* -------------------- Reduce the arrays removing any duplicate timestamps// ------------------- */
  let unmitigatedDamageTimestampsReducedWithCooldowns = reduceTimestamps(unmitigatedDamageFromLogWithTimesAddedAndCooldowns);
  let mitigatedDamageTimestampsReducedWithCooldowns = reduceTimestamps(mitigatedDamageFromLogWithTimesAddedAndCooldowns);
  let unmitigatedDamageTimestampsReducedNoCooldowns = reduceTimestamps(unmitigatedDamageFromLogWithTimesAddedNoCooldowns);
  let mitigatedDamageTimestampsReducedNoCooldowns = reduceTimestamps(mitigatedDamageFromLogWithTimesAddedNoCooldowns);

  /* ------------------------------------- Push To new arrays ------------------------------------- */
  Object.keys(unmitigatedDamageTimestampsReducedWithCooldowns).forEach((element) => sortedDataUnmitigatedWithCooldowns.push(unmitigatedDamageTimestampsReducedWithCooldowns[element]));
  Object.keys(mitigatedDamageTimestampsReducedWithCooldowns).forEach((element) => sortedDataMitigatedDamageWithCooldowns.push(mitigatedDamageTimestampsReducedWithCooldowns[element]));
  Object.keys(unmitigatedDamageTimestampsReducedNoCooldowns).forEach((element) => sortedDataUnmitigatedNoCooldowns.push(unmitigatedDamageTimestampsReducedNoCooldowns[element]));
  Object.keys(mitigatedDamageTimestampsReducedNoCooldowns).forEach((element) => sortedDataMitigatedDamageNoCooldowns.push(mitigatedDamageTimestampsReducedNoCooldowns[element]));

  /* ---------------------------------------------------------------------------------------------- */
  /*                                    DTPS Graph data creation                                    */
  /* ---------------------------------------------------------------------------------------------- */

  let summedUnmitigationDamage = sumDamage(sortedDataUnmitigatedNoCooldowns, fightLength);

  let summedUnmitigatedDamagePerSecond = Object.keys(summedUnmitigationDamage)
    .filter((obj) => {
      return obj !== "timestamp";
    })
    .map((key) => {
      return {
        ability: key,
        damage: Math.round(summedUnmitigationDamage[key] / fightLength),
      };
    })
    .sort((a, b) => (b.damage > a.damage ? 1 : -1));

  let summedMitigationDamage = sumDamage(sortedDataMitigatedDamageNoCooldowns, fightLength);
  let summedMitigationDamagePerSecond = Object.keys(summedMitigationDamage)
    .filter((obj) => {
      return obj !== "timestamp";
    })
    .map((key) => {
      return {
        ability: key,
        damage: Math.round(summedMitigationDamage[key] / fightLength),
      };
    })
    .sort((a, b) => (b.damage > a.damage ? 1 : -1));

  /* ---------- Here we set all the returned data to state in the FightAnalysis Component --------- */
  this.setState({
    /* ------------------------ Store the original Unmitigated data in state ------------------------ */
    unmitigatedChartDataNoCooldownsOriginal: sortedDataUnmitigatedNoCooldowns,
    unmitigatedChartDataNoCooldowns: sortedDataUnmitigatedNoCooldowns,

    /* ------------------------- Store the original mitigated data in state ------------------------- */
    mitigatedChartDataNoCooldownsOriginal: sortedDataMitigatedDamageNoCooldowns,
    mitigatedChartDataNoCooldowns: sortedDataMitigatedDamageNoCooldowns,

    legenddata: uniqueArrayNewForLegend,
    /* ------------------ Unmitigated Chart Data - With Cooldowns Used from the log ----------------- */
    unmitigatedChartData: sortedDataUnmitigatedWithCooldowns,
    mitigatedChartData: sortedDataMitigatedDamageWithCooldowns,

    Updateddatacasts: updateddatacastsTimeline,
    defensiveCasts: defensiveCasts,
    abilityList: uniqueArray,
    cooldownlist: uniqueArrayCD,
    loadingcheck: false,
    healernames: summary.map((key) => ({
      name: key.name,
      icon: key.icon,
      combatantInfo: key.combatantInfo,
      type: key.type,
      stats: [
        {
          intellect: key.combatantInfo.stats.Intellect ? key.combatantInfo.stats.Intellect["min"] : 0,
          crit: key.combatantInfo.stats.Crit ? key.combatantInfo.stats.Crit["min"] : 0,
          haste: key.combatantInfo.stats.Haste ? key.combatantInfo.stats.Haste["min"] : 0,
          mastery: key.combatantInfo.stats.Mastery ? key.combatantInfo.stats.Mastery["min"] : 0,
          versatility: key.combatantInfo.stats.Versatility ? key.combatantInfo.stats.Versatility["min"] : 0,
          leech: key.combatantInfo.stats.Leech ? key.combatantInfo.stats.Leech["min"] : 0,
          ilvl: key.combatantInfo.stats["Item Level"] ? key.combatantInfo.stats["Item Level"]["min"] : 0,
        },
      ],
    })),
    currentEndTime: endtime,
    currentStartTime: starttime,
    summedUnmitigatedDamagePerSecond: summedUnmitigatedDamagePerSecond,
    summedMitigationDamagePerSecond: summedMitigationDamagePerSecond,
    externalUsageTimelineData: updateddatacastsExternalsTimeline,
    enemyCastsTimelineData: enemyCastsTimeline,
  });
}
